![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_01.png)

~~~C
.pos 0x100
	irmovq $15, %rbx
	rrmovq %rbx, %rcx
loop:
	rmmovq %rcx, -3(%rbx)
	addq %rbx, %rcx
	jmp loop
	
0x100 30f30f00000000000000
0x10a 2031
0x10c 4013fdffffffffffffff
0x116 6031
0x118 700c01000000000000
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_02.png)

* A. 

~~~C
irmovq $-4, %rbx
rmmovq %rsi, 0x800(%rbx)
~~~

* B.

~~~C
pushq %rsi
call 0x000000000000020c
halt
irmovq $10, %rbx
ret
~~~

* C.

~~~C
mrmovq 7(%rbp), %rsp
nop
❌没有 f0 的指令
~~~

* D.

~~~C
subq %rcx, %rbx
je 0x0000000000000400
halt
~~~

* E.

~~~C
xorq %rsi, %rdx
❌ push 指令的操作数和寄存器写反了
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_03.png)

~~~C
sum:
	xorq %rax, %rax
	andq %rsi, %rsi
	jmp test
loop:
	mrmovq (%rdi), %r10
	addq %r10, %rax
	addq $8, %rdi
	subq $1, %rsi
test:
	jne loop
	ret
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_04.png)

~~~C
rsum:
	push %rbp
	push %r10
	rrmovq %rsp, %rbp
	push %rbx
	irmovq $24, %r10
	subq %r10, %rsp
	rmmovq %rdi, -24(%rbp)
	rmmovq %rsi, -28(%rbp)
	mrmovq -28(%rbp), %r10
	andq %r10, %r10
	jg .L2
	irmovq $0, %rax
	jmp .L3
.L2:
	mrmovq -24(%rbp), %rax
	mrmovq (%rax), %rbx
	mrmovq -28(%rbp), %rax
	rrmovq %rax, %rdx
	subq $1, %rdx
	mrmovq -24(%rsp), %rax
	irmovq $8, %r10
	addq %r10, %rax
	rrmovq %rdx, %rsi
	rrmovq %rax, %rdi
	call rsum
	addq %rbx, %rax
.L3:
	irmovq $24, %r10
	addq %r10, %rsp
	popq %rbx
	popq %r10
	popq %rbp
	ret
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_05.png)

~~~C
absSum:
	irmovq $8, %r8
	irmovq $1, %r9
	xorq %rax, %rax
	andq %rsi, %rsi
	jmp test
loop:
	mrmovq (%rdi), %r10
	andq %r10, %r10
	jge .L1
	irmovq $0, %r11
	subq %r10, %r11
	rrmovq %r11, %r10
.L1:
	addq %r10, %rax
	addq %r8, %rdi
	subq %r9, %rsi
test:
	jne loop
	ret
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_06.png)

~~~C
absSum:
	irmovq $8, %r8
	irmovq $1, %r9
	xorq %rax, %rax
	andq %rsi, %rsi
	jmp test
loop:
	mrmovq (%rdi), %r10
	xorq %r11, %r11
	subq %r10, %r11
	andq %r10, %r10
	cmovl %r11, %r10
	addq %r10, %rax
	addq %r8, %rdi
	subq %r9, %rsi
test:
	jne loop
	ret
~~~


![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_07.png)

push %rsp 时发生了如下事件 

* 取指
* 译码 `valA = rA, valB = %rsp`
* 执行 `valE = valB - 8`
* 访存 `M(valE) = valA`
* 写回 `%rsp = valE`
* 更新 

因为访存时写到内存中的是 %rsp 的 -8 之前的值

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_08.png)

pop %rsp 时发生了如下事件

* 取值
* 译码 `valA = %rsp, valB = %rsp`
* 执行 `valE = valB + 8`
* 访存 `valM = M(valA)`
* 写回 `%rsp = valE` `rA = valM`
* 更新

在写回阶段，%rsp 中的值被赋值成 valM

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_09.png)

* `bool xor = (!a && b) || (a && !b)`
* 关系就是 xor 为 1，eq 必为 0，反之亦然

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_10.png)

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_10_01.png)

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_11.png)

~~~C
word Min3 = {
	A <= B && A <= C : A;
	B <= C : B;
	1 : C;
}
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_12.png)

~~~C
word Mid3 = {
	A <= B && B <= C :  B;
	C <= B && B <= A :  A;
	A <= C && C <= B :  C;
	B <= C && C <= A :  C;
	1					:  A; 
}
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_13.png)

* `icode:ifun  30`
* `rA:rB f4`
* `valC 128`
* `valP 0x016 + a = 0x020`

* `valE = 128`
* `R[rB] <-- 128`
* `PC = 0x020`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_14.png)

* `icode:ifun b0`
* `rA:rB 0:f`
* `valP = 0x02c + 2 = 0x02E`
* `valA = 120`
* `valB = 120`
* `valE = 120 + 8 = 128`
* `valM = 9`
* `R[%rsp] = 128`
* `R[rA] = 9`
* `PC = valP = 0x02E`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_15.png)

~~~C
取指: icode:ifun
	  rA:rB
	  valP = PC + 2
译码: valA = %rsp, valB = %rsp
执行: valE = valB - 8
访存: M[valE] = valA
写回: %rsp = valE
更新 PC = valP
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_16.png)

~~~C
取值: icode:ifun
	  rA:rB
	  valP = PC + 2
译码: valA = %rsp, valB = %rsp
执行: valE = valB + 8
访存: valM = M[valA]
写回: %rsp = valE
	  %rsp = valM
更新 PC = valP
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_17.png)

* 执行时 `Cnd = Cond(CC, ifun)`
* 写回时 `if Cnd R[rB] = valE`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch4%20处理器体系结构/images/practise_04_18.png)

~~~C
icode:ifun 80

valC = 0x041
valP = 0x37 + 9 = 0x40

valB = %rsp

valE = valB - 8

M[valE] = valP

%rsp = valE

PC = valC
~~~







