![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_01.png)

* `0x100`
* `0xAB`
* `0x13`
* `0xAB`
* `0x11`
* `0x13`
* `0xFF`
* `0x11`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_02.png)

* `l`
* `w`
* `b`
* `b`
* `q`
* `w`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_03.png)

* x86-64 架构寻址必须用 64 位地址，因此不能用 32 位寄存器作为地址访问内存。
* 指令指定要操作的是双字，但寄存器用了 64 位的。
* 不能直接移动内存到内存，要用寄存器作为中间暂存。
* 没有 sl，而是 sil
* 立即数不能作为目的
* 操作的源寄存器和目的寄存器类型不匹配
* si 单位是字

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_04.png)

* `char int`
	* `movsbl (%rdi), %eax`
	* `movl %eax, (%rsi)`

* `char unsigned`
	* `movzbl (%rdi), %eax`
	* `movl %eax, (%rsi)`

* `unsigned char, long`
	* `movzbq (%rdi), %rax`
	* `movq %rax, (%rsi)`

* `int char`
	* `movl (%rdi), %eax`
	* `movb %al, (%rsi)`

* `unsigned unsigned char`
	* `movl (%rdi), %eax`
	* `movb %al, (%rsi)`

* `char short`
	* `movsbw (%rdi), %ax`
	* `movs %al, (%rsi)`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_05.png)

~~~C
*yp = *xp;
*zp = *yp;
*xp = *zp;
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_06.png)

* `6 + x`
* `x + y`
* `x + 4y`
* `9x + 7`
* `4y + A`
* `x + 2y + 9`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_07.png)

`5x + 2y + 8z`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_08.png)

* `0x100` `0x100`
* `0x108` `0xA8`
* `0x118` `0x110`
* `0x110` `0x14`
* `%rcx` `0`
* `%rax` `0xFD`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_09.png)

* `salq $4, %rax`
* `sarq %cl, %rax`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_10.png)

* `z - ~((x | y) >> 3)`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_11.png)

* A. 将 %rdx 清零
* B. `movl $0, %rdx`
* C. `xorl %edx, %edx` 2 字节，`movl $0, %edx` 5 字节

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_12.png)

~~~C
mov %rdx, %r8
movq %rdi, %rax
cqto
divq %rsi
movq %rax, (%r8)
movq %rdx, (%rcx)
ret
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_13.png)

* A. `int <`
* B. `short >=`
* C. `unsigned char <=`
* D. `long, unsigned long, pointer !=`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_14.png)

* A. `long >=`
* B. `short unsigned short ==`
* C. `unsigned char >`
* D. `int unsigned int !=`  这里书上的答案只有 int, 但经过测试，编译器的确会对 `data_t` 为 unsigned int 的代码生成同样的汇编。使用的优化等级为 `-O1`




















