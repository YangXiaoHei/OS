![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_01.png)

* `0x100`
* `0xAB`
* `0x13`
* `0xAB`
* `0x11`
* `0x13`
* `0xFF`
* `0x11`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_02.png)

* `l`
* `w`
* `b`
* `b`
* `q`
* `w`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_03.png)

* x86-64 架构寻址必须用 64 位地址，因此不能用 32 位寄存器作为地址访问内存。
* 指令指定要操作的是双字，但寄存器用了 64 位的。
* 不能直接移动内存到内存，要用寄存器作为中间暂存。
* 没有 sl，而是 sil
* 立即数不能作为目的
* 操作的源寄存器和目的寄存器类型不匹配
* si 单位是字

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_04.png)

* `char int`
	* `movsbl (%rdi), %eax`
	* `movl %eax, (%rsi)`

* `char unsigned`
	* `movzbl (%rdi), %eax`
	* `movl %eax, (%rsi)`

* `unsigned char, long`
	* `movzbq (%rdi), %rax`
	* `movq %rax, (%rsi)`

* `int char`
	* `movl (%rdi), %eax`
	* `movb %al, (%rsi)`

* `unsigned unsigned char`
	* `movl (%rdi), %eax`
	* `movb %al, (%rsi)`

* `char short`
	* `movsbw (%rdi), %ax`
	* `movs %al, (%rsi)`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_05.png)

~~~C
*yp = *xp;
*zp = *yp;
*xp = *zp;
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_06.png)

* `6 + x`
* `x + y`
* `x + 4y`
* `9x + 7`
* `4y + A`
* `x + 2y + 9`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_07.png)

`5x + 2y + 8z`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_08.png)

* `0x100` `0x100`
* `0x108` `0xA8`
* `0x118` `0x110`
* `0x110` `0x14`
* `%rcx` `0`
* `%rax` `0xFD`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_09.png)

* `salq $4, %rax`
* `sarq %cl, %rax`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_10.png)

* `z - ~((x | y) >> 3)`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_11.png)

* A. 将 %rdx 清零
* B. `movl $0, %rdx`
* C. `xorl %edx, %edx` 2 字节，`movl $0, %edx` 5 字节

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_12.png)

~~~C
mov %rdx, %r8
movq %rdi, %rax
cqto
divq %rsi
movq %rax, (%r8)
movq %rdx, (%rcx)
ret
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_13.png)

* A. `int <`
* B. `short >=`
* C. `unsigned char <=`
* D. `long, unsigned long, pointer !=`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_14.png)

* A. `long >=`
* B. `short unsigned short ==`
* C. `unsigned char >`
* D. `int unsigned int !=`  这里书上的答案只有 int, 但经过测试，编译器的确会对 `data_t` 为 unsigned int 的代码生成同样的汇编。使用的优化等级为 `-O1`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_15.png)

* A. `4003fe`
* B. `400425`
* C. `400543` `400545`
* D. `400560`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_16.png)

* A.
~~~C
if (p == 0)
	goto done;
if (*p >= a)
	goto done;
*p = a;
done:
return;
~~~

* B. 因为在一个 if 语句中判断了两个条件

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_17.png)

* A.
~~~C
if (x < y)
	goto ok;
ge_cnt++;
result = x - y;
return result;
ok:
	lt_cnt++;
	result = y - x;
return result;
~~~

* B. 如果条件判断没有 else 分支的话，继续采用第二种翻译规则会变成这样

~~~C
if (condition)
	goto fit_condition;
empty statement
return;
fit_condition:
	things really do
return;
~~~

如果采用第一种规则会变成

~~~C
if (!condition)
	goto done;
	things really do
done:
return;	
~~~

可以看出，下面这种代码更友好一些，代码体积更小，条件满足可以和条件不满足共用一个结束流程。 

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_18.png)

* 由题目给出的部分代码推断，在第一个判断满足后的跳转中，会再有两个分支，因此，假如把 `x >= -3` 当作第一个 if 的判断语句，那么跳转到 `.L2` 后，可以看到，若  `x <= 2` 程序直接退出，不会再有第二个 `val` 的赋值，因此第一个 if 语句的条件一定是 `x < -3`

~~~C
long test(long x, long y, long z) {
	long val = x + y + z;
	if (x < -3) {
		if (y >= z)
			val = y * z;
		else
			val = x * y;
	} else if (x > 2)
		val = x * z;
	return val;
}
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_19.png)

* A. `Tavg(p) = Tok + pTmp`
* 由公式可以知道，假如模式是随机的，也就是说 `Tok + 0.5Tmp = 31`，假如是非常可预测的，那么 `Tok = 16`，因此 `Tmp = 15/0.5 = 30`
* B. 当分支预测错误时，这个函数需要 `30 + 16 = 36` 个时钟周期

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_20.png)

* A. OP 进行的操作是除法
* B.

~~~C
arith:
	leaq 7(%rdi), %rax		; 假设 x 是负数，那么对齐位移替代除法需要做加上偏置量 7
	testq %rdi, %rdi			; if x < 0 ?
	cmovns %rdi, %rax		; if x < 0  t = x + 7
	sarq $3, %rax				; t >>= 3，将 t 作为返回值
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_21.png)

~~~C
long test(long x, long y) {
	long val = 8 * x;
	if (y > 0) {
		if (x > y)
			val = x & y;
		else
			val = y - x;	
	} else if (y <= -2)
		val = x + y;
	return val;
}
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_22.png)

* A. 由上述程序可以算出，用 32 位 int 表示 n!，最大的 n 是 12
* B. 用 64 位 long 表示，最大的 n 是 20

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_23.png)

* A. `%rcx` 用来放 y, `%rax` 用来放 x, `%rdx` 用来放 n
* B. 因为 x 的值取出来就是美轮美奂循环加个 1，那不如和 `x += y` 合并一下，变成 `x += (y + 1)` 就好咯
* C. 

~~~C
dw_loop:
	movq %rdi, %rax				; t = x
	movq %rdi, %rcx
	imulq %rdi, %rcx				; x^2
	leaq (%rdi, %rdi), %rdx		; i = 2x
.L2:
	leaq 1(%rcx, %rax), %rax	; t = t + x^2 + 1
	subq $1, %rdx					; i--
	testq %rdx, %rdx				; if i > 0 goto L2
	jg .L2
	rep
	ret
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_24.png)

~~~C
long loop_while(long a, long b)
{
	long result = 1;
	while (a < b) {
		result *= (a + b);
		a++;
	}
	return result;
}
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_25.png)

~~~C
long result = b;
while (b > 0) {
	result *= a;
	b -= a;
}
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_26.png)

* A. `jmp-to-middle`
* B. 

~~~C
long fun_a(unsigned long x) {
	long val = 0;
	while (x != 0) {
		val ^= x;
		x >>= 1;
	}
	return val & 1;
}
~~~

* C. 确定是奇数个 1 还是偶数个 1

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_27.png)

~~~C
long fact_for(long n)
{
	long i = 2;;
	long result = 1;
	while (i <= n) {
		result *= i;
		i++;
	}
}

	push %rbp
	movq %rsp, %rbp
	movl $1, %eax
	movl $2, %ecx
	cmp %rdi, %rcx
	jg done
fact_for_loop:
	imulq %rcx, %rax
	addq %rcx
	cmp %rdi, %rcx
	jle fact_for_loop
done:
	mov %rbp, %rsp
	pop %rbp
	rep
	ret
	
long fact_for_goto(long n)
{
	long result = 1;
	long i = 2;
	if (i > n)
		goto done;
		
fact_for_loop:
	result *= i;
	i++;
	if (i <= n) 
		goto fact_for_loop;
	return result;
}
	
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_28.png)

* A.
~~~C
long fun_b(unsigned long x)
{
	long val = 0;
	long i;
	for (i = 64; i != 1; i--) {
		val <<= 1;
		val |= (x & 1);
		x >>= 1;
	}
	return val;
}
~~~

* B. 这个测试是通过 sub 命令所设置的标志寄存器来做的，所以不需要额外测试
* C. 这个函数将 x 的二进制位模式反转

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_29.png)

~~~C
手写的汇编...

	movl $0, %eax
	movl $0, %ecx
	cmpq $10, %rcx
	jge done

do_things_loop:
	movl %ecx, %edx
	andq $1, %rdx
	jz not_do_anything
	addq %rcx, %rax 
not_do_anything:
	addl $1, %ecx
	cmpq $10, %rcx
	jl do_things_loop

done:
	rep
	ret
	
手写的 goto 函数...

	long sum = 0;
	long i = 0;
	if (i > 10)
		goto done;
	
do_things_loop:
	if (i & 1 == 0)
		goto do_nothing;
		
	sum += i;
	
do_nothing:
	i++;
	goto do_things_loop;
	
done:
	return sum;
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_30.png)

* A. 最小标号是 -1，标号分别为 -1, 0, 1, 2, 4, 5, 7
* B. 标号 2 和标号 4 共用，0 和  7 共用


![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_31.png)

~~~C
void switcher(long a, long b, long c, long *dest)
{
	long val;
	switch(a) {
		case 0:
			val = c + 112;
			break;
		case 2:
		case 7:
			val = (b + c) << 2;
			break;
		case 4:
			val = a;
			break;
		case 5:
			val = b ^ 5;
			break;
		default:
			val = b;
	}
	return val;
}
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_32.png)

||||||||||
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|标号|PC| 指令|%rdi|%rsi|%rax|%rsp|*%rsp|描述|
|M1|0x400560|callq|10|-|-|0x7fffffffe820|-|调用 first(10)|
|F1|0x400548|lea|10|11|-|0x7fffffffe818|0x400565|-|
|F2|0x40054c|sub| 9|11|-|0x7fffffffe818|0x400565|-|
|F3|0x400550|callq|9|11|-|0x7fffffffe818|0x400565|-|
|L1|0x400540|mov|9|11|9|0x7fffffffe810|0x400555|-|
|L2|0x400543|imul|9|11|99|0x7fffffffe810|0x400555|-|
|L3|0x400547|retq|9|11|99|0x7fffffffe810|0x400555|-|
|F4|0x400555|repz|9|11|99|0x7fffffffe818|0x400565|-|
|M2|0x400565|mov|9|11|99|0x7fffffffe810|-|-|

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_33.png)

* 从 `movl $6, %eax` 猜测，一定是一个 int 和一个 short, 根据 `movslq %edi, %rdi` 验证，第一个参数是 int, 第二个是 short。
* 从 3, 4 句得知，第 3, 4 个参数都是指针，并且 addq，说明第 3 个是 `long *`，addb，说明第 4 个是 `char *`。

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_34.png)

* A. `x + 1`, `x + 2`, `x + 3`, `x + 4`, `x + 5` 在寄存器里。
* B. `x + 6`, `x + 7` 在栈里
* C. 因为被调用者保存的寄存器用光了 


















