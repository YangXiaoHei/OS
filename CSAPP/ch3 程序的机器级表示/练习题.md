![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_01.png)

* `0x100`
* `0xAB`
* `0x13`
* `0xAB`
* `0x11`
* `0x13`
* `0xFF`
* `0x11`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_02.png)

* `l`
* `w`
* `b`
* `b`
* `q`
* `w`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_03.png)

* x86-64 架构寻址必须用 64 位地址，因此不能用 32 位寄存器作为地址访问内存。
* 指令指定要操作的是双字，但寄存器用了 64 位的。
* 不能直接移动内存到内存，要用寄存器作为中间暂存。
* 没有 sl，而是 sil
* 立即数不能作为目的
* 操作的源寄存器和目的寄存器类型不匹配
* si 单位是字

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_04.png)

* `char int`
	* `movsbl (%rdi), %eax`
	* `movl %eax, (%rsi)`

* `char unsigned`
	* `movzbl (%rdi), %eax`
	* `movl %eax, (%rsi)`

* `unsigned char, long`
	* `movzbq (%rdi), %rax`
	* `movq %rax, (%rsi)`

* `int char`
	* `movl (%rdi), %eax`
	* `movb %al, (%rsi)`

* `unsigned unsigned char`
	* `movl (%rdi), %eax`
	* `movb %al, (%rsi)`

* `char short`
	* `movsbw (%rdi), %ax`
	* `movs %al, (%rsi)`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_05.png)

~~~C
*yp = *xp;
*zp = *yp;
*xp = *zp;
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_06.png)

* `6 + x`
* `x + y`
* `x + 4y`
* `9x + 7`
* `4y + A`
* `x + 2y + 9`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_07.png)

`5x + 2y + 8z`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_08.png)

* `0x100` `0x100`
* `0x108` `0xA8`
* `0x118` `0x110`
* `0x110` `0x14`
* `%rcx` `0`
* `%rax` `0xFD`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_09.png)

* `salq $4, %rax`
* `sarq %cl, %rax`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_10.png)

* `z - ~((x | y) >> 3)`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_11.png)

* A. 将 %rdx 清零
* B. `movl $0, %rdx`
* C. `xorl %edx, %edx` 2 字节，`movl $0, %edx` 5 字节

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_12.png)

~~~C
mov %rdx, %r8
movq %rdi, %rax
cqto
divq %rsi
movq %rax, (%r8)
movq %rdx, (%rcx)
ret
~~~

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_13.png)

* A. `int <`
* B. `short >=`
* C. `unsigned char <=`
* D. `long, unsigned long, pointer !=`

![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/practise_03_14.png)

* A. `long >=`
* B. `short unsigned short ==`
* C. `unsigned char >`
* D. `int unsigned int !=`  这里书上的答案只有 int, 但经过测试，编译器的确会对 `data_t` 为 unsigned int 的代码生成同样的汇编。使用的优化等级为 `-O1`

3.15

* A. `4003fe`
* B. `400425`
* C. `400543` `400545`
* D. `400560`

3.16

* A.
~~~C
if (p == 0)
	goto done;
if (*p >= a)
	goto done;
*p = a;
done:
return;
~~~

* B. 因为在一个 if 语句中判断了两个条件

3.17

* A.
~~~C
if (x < y)
	goto ok;
ge_cnt++;
result = x - y;
return result;
ok:
	lt_cnt++;
	result = y - x;
return result;
~~~

* B. 如果条件判断没有 else 分支的话，继续采用第二种翻译规则会变成这样

~~~C
if (condition)
	goto fit_condition;
empty statement
return;
fit_condition:
	things really do
return;
~~~

如果采用第一种规则会变成

~~~C
if (!condition)
	goto done;
	things really do
done:
return;	
~~~

可以看出，下面这种代码更友好一些，代码体积更小，条件满足可以和条件不满足共用一个结束流程。 

3.18

* 由题目给出的部分代码推断，在第一个判断满足后的跳转中，会再有两个分支，因此，假如把 `x >= -3` 当作第一个 if 的判断语句，那么跳转到 `.L2` 后，可以看到，若  `x <= 2` 程序直接退出，不会再有第二个 `val` 的赋值，因此第一个 if 语句的条件一定是 `x < -3`

~~~C
long test(long x, long y, long z) {
	long val = x + y + z;
	if (x < -3) {
		if (y >= z)
			val = y * z;
		else
			val = x * y;
	} else if (x > 2)
		val = x * z;
	return val;
}
~~~

3.19

* A. `Tavg(p) = Tok + pTmp`
* 由公式可以知道，假如模式是随机的，也就是说 `Tok + 0.5Tmp = 31`，假如是非常可预测的，那么 `Tok = 16`，因此 `Tmp = 15/0.5 = 30`
* B. 当分支预测错误时，这个函数需要 `30 + 16 = 36` 个时钟周期

3.20

* A. OP 进行的操作是除法
* B.

~~~C
arith:
	leaq 7(%rdi), %rax		; 假设 x 是负数，那么对齐位移替代除法需要做加上偏置量 7
	testq %rdi, %rdi			; if x < 0 ?
	cmovns %rdi, %rax		; if x < 0  t = x + 7
	sarq $3, %rax				; t >>= 3，将 t 作为返回值
~~~

3.21

~~~C
long test(long x, long y) {
	long val = 8 * x;
	if (y > 0) {
		if (x > y)
			val = x & y;
		else
			val = y - x;	
	} else if (y <= -2)
		val = x + y;
	return val;
}
~~~

3.22

* A. 由上述程序可以算出，用 32 位 int 表示 n!，最大的 n 是 12
* B. 用 64 位 long 表示，最大的 n 是 20

3.23

* A. `%rcx` 用来放 y, `%rax` 用来放 x, `%rdx` 用来放 n
* B. 因为 x 的值取出来就是美轮美奂循环加个 1，那不如和 `x += y` 合并一下，变成 `x += (y + 1)` 就好咯
* C. 

~~~C
dw_loop:
	movq %rdi, %rax				;
	movq %rdi, %rcx
	imulq %rdi, %rcx
	leaq (%rdi, %rdi), %rdx
.L2:
	leaq 1(%rcx, %rax), %rax
	subq $1, %rdx
	testq %rdx, %rdx
	jg .L2
	rep
	ret
~~~


















