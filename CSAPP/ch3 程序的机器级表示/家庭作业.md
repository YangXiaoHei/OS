3.58

~~~C
long decode2(long x, long y, long z)
{
	long t = z - y;
	long k = x * (z - y);
	t <<= 63;
	t >>= 63;
	return k ^ t;
}
~~~

3.59

~~~C
x_64 表示 x(128) 的高 64 位

x(128)' = x + x_64 * 2^64
y(128)' = y + y_64 * 2^64

x' * y' = xy + x * y_64 * 2^64 + y * x_64 * 2^64 + x_64 * y_64 * 2^128
2^128 溢出，因此不用管

x' * y' = xy + x * y_64 * 2^64 + y * x_64 * 2^64

x' * y' = ux * uy + (x * y_64  + y * x_64) * 2^64
~~~

~~~C
store_prod:
	movq %rdx, %rax		; %rax = y
	cqto 					; %rdx = y_64
	movq %rsi, %rcx		; %rcx = x
	sarq $63, %rcx		; %rcx = x_64
	imulq %rax, %rcx		; %rcx = y * x_64
	imulq %rsi, %rdx		; %rdx = x * y_64
	addq	%rdx, %rcx	; %rcx = y * x_64 + x * y_64
	mulq  %rsi			; 无符号乘法 %rdx:%rax = ux * uy
	addq %rcx, %rdx		; %rdx = (ux * uy)_64 + y * x_64 + x * y_64
	movq %rax, (%rdi)	; 结果的低 64 位, (ux * uy)_low63 == (x * y)_low64
	mov %rdx, 8(%rdi)   ; 结果的高 64 位
	ret
~~~

3.60

* A. %rdi 保存 x, %rsi 保存 n, %rax 保存 result, %rdx 保存 mask
* B. result 和 mask 的初始值是 0, 1
* C. mask 的测试条件是 mask != 0
* D. mask 每次左移 n 位
* E. result 通过 x 与掩码与的结果或来修改
* F. 如下

~~~C
long loop(long x, int n)
{
	long result = 0;
	long mask;
	for (mask = 1; mask != 0; mask <<= 1) {
		result |= (x & mask);
	}
	return result;
}
~~~

3.62

~~~C
typedef enum { MODE_A, MODE_B, MODE_C, MODE_D, MODE_E } mode_t;

long switch3(long *p1, long *p2, mode_t action)
{
	long result = 0;
	switch (action) {
		case MODE_A:
			result = *p2;
			*p2 = *p1;
			break;
		
		case MODE_B:
			result = *p1 + *p2;
			*p1 = result;
			break;
		
		case MODE_C:
			*p1 = 59;
			result = *p2;
			break;
			
		case MODE_D:
			*p1 = *p2;
			result = 27;
			break;
			
		case MODE_E:
			result = 27;
			break;
			
		default:
			result = 12;
			break;
	}
	return result;
}
~~~

3.63

~~~C
long switch_prob(long x, long n)
{
	long result = x;
	switch(n) {
		case 50:
		case 52:
			result = 8 * x;
			break;
		
		case 53:
			result = x / 8;
			break;
		
		case 54:
			x *= 15;
		case 55:
			x *= x;
		case 51:
			result = 75 + x;
			break;
	} 
	return result;
}
~~~

3.64

* A. A + L(S * T * i + T * j + k)
* B.
 
~~~C
store_ele:
	leaq (%rsi, %rsi, 2), %rax
	leaq (%rsi, %rax, 4), %rax		; 13j
	movq %rdi, %rsi					
	salq $6, %rsi						; 64i
	addq %rsi, %rdi					; %rdi = 65i
	addq %rax, %rdi					; %rdi = 65i + 13j
	addq %rdi, %rdx					; %rdx = 65i + 13j + k
	movq A(, %rdx, 8), %rax			; %rax = [A + 8(65i + 13j + k)]
	movq %rax, (%rcx)				; *dest = %rax
	movl $3640, %eax					; R * T * S * 8 = 3640
~~~

* 从上面的分析可知
* S * T = 65
* T = 13, 因此 S = 5
* 由于 T * S * R * 8 = 3640 => R = 7
* 综上所述 S = 5, T = 13, R = 7

3.65

* A. %rdx 保存着 A[i][j] 的指针。
* B. %rax 保存着 A[j][i] 的指针
* C. M 的值是 15

3.66

~~~C
sum_col:
	leaq	1(, %rdi, 4), %r8			; %r8 = 4n+1
	leaq 	(%rdi, %rdi, 2), %rax		; %rax = 3n 
	movq	%rax, %rdi					; %rdi = 3n
	testq  %rax, %rax					; if 3n <= 0, return 0
	jle		.L4			
	salq	$3, %r8						; %r8 = 8(4n + 1)
	leaq	(%rsi, %rdx, 8), %rcx		; %rcx = A + 8j
	movl 	$0, %eax						; %rax = 0
	movl   $0, %edx						; %rdx = 0
.L3
	addq	(%rcx), %rax					; %rax = A[i][j]
	addq  $1, %rdx						; %rdx++
	addq  %r8, %rcx						; A + 8j + 8(4n+1) = A + 8(4n+1 + j)
	cmpq %rdi, %rdx						; if i < 3n, loop 
	jne .L3
	rep
	ret
.L4:
	movl $0, %eax
	ret  
~~~

* 从上面的分析可以看出，NC(n) = 4n + 1, NR(n) = 3n

3.67

* A. 栈帧如图所示 
* ![](https://github.com/YangXiaoHei/OS/blob/master/CSAPP/ch3%20程序的机器级表示/images/homework_03_67.png)
* B. eval 调用 process 时传递了 `strB r` 的地址, `strB r` 的内存是在 eval 中和 `strA s` 一起被分配的
* C. 通过 %rsp 加上偏移访问 s，%rsp + 8 访问 x, + 16 访问 y, + 24 访问 &z, 通过 + 32 访问 z
* D. 通过 %rdi 加上偏移作为 %rsp 的偏移来访问 r
* E. 通过 %rsp 加上偏移来访问...
* F. 













