3.58

~~~C
long decode2(long x, long y, long z)
{
	long t = z - y;
	long k = x * (z - y);
	t <<= 63;
	t >>= 63;
	return k ^ t;
}
~~~

3.59

~~~C
x_64 表示 x(128) 的高 64 位

x(128)' = x + x_64 * 2^64
y(128)' = y + y_64 * 2^64

x' * y' = xy + x * y_64 * 2^64 + y * x_64 * 2^64 + x_64 * y_64 * 2^128
2^128 溢出，因此不用管

x' * y' = xy + x * y_64 * 2^64 + y * x_64 * 2^64

x' * y' = ux * uy + (x * y_64  + y * x_64) * 2^64
~~~

~~~C
store_prod:
	movq %rdx, %rax		; %rax = y
	cqto 					; %rdx = y_64
	movq %rsi, %rcx		; %rcx = x
	sarq $63, %rcx		; %rcx = x_64
	imulq %rax, %rcx		; %rcx = y * x_64
	imulq %rsi, %rdx		; %rdx = x * y_64
	addq	%rdx, %rcx	; %rcx = y * x_64 + x * y_64
	mulq  %rsi			; 无符号乘法 %rdx:%rax = ux * uy
	addq %rcx, %rdx		; %rdx = (ux * uy)_64 + y * x_64 + x * y_64
	movq %rax, (%rdi)	; 结果的低 64 位, (ux * uy)_low63 == (x * y)_low64
	mov %rdx, 8(%rdi)   ; 结果的高 64 位
	ret
~~~

3.60

* A. %rdi 保存 x, %rsi 保存 n, %rax 保存 result, %rdx 保存 mask
* B. 

~~~C
long loop(long x, int n)
{
	long result = 0;
	long mask;
	for (mask = 1; mask != 0; mask <<= 1) {
		result |= (x & mask);
	}
	return result;
}
~~~










