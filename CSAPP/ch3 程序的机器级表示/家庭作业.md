3.58

~~~C
long decode2(long x, long y, long z)
{
	long t = z - y;
	long k = x * (z - y);
	t <<= 63;
	t >>= 63;
	return k ^ t;
}
~~~

3.59

~~~C
x_64 表示 x(128) 的高 64 位

x(128)' = x + x_64 * 2^64
y(128)' = y + y_64 * 2^64

x' * y' = xy + x * y_64 * 2^64 + y * x_64 * 2^64 + x_64 * y_64 * 2^128
2^128 溢出，因此不用管

x' * y' = xy + x * y_64 * 2^64 + y * x_64 * 2^64

x' * y' = ux * uy + (x * y_64  + y * x_64) * 2^64
~~~

~~~C
store_prod:
	movq %rdx, %rax		; %rax = y
	cqto 					; %rdx = y_64
	movq %rsi, %rcx		; %rcx = x
	sarq $63, %rcx		; %rcx = x_64
	imulq %rax, %rcx		; %rcx = y * x_64
	imulq %rsi, %rdx		; %rdx = x * y_64
	addq	%rdx, %rcx	; %rcx = y * x_64 + x * y_64
	mulq  %rsi			; 无符号乘法 %rdx:%rax = ux * uy
	addq %rcx, %rdx		; %rdx = (ux * uy)_64 + y * x_64 + x * y_64
	movq %rax, (%rdi)	; 结果的低 64 位, (ux * uy)_low63 == (x * y)_low64
	mov %rdx, 8(%rdi)   ; 结果的高 64 位
	ret
~~~

3.60

* A. %rdi 保存 x, %rsi 保存 n, %rax 保存 result, %rdx 保存 mask
* B. result 和 mask 的初始值是 0, 1
* C. mask 的测试条件是 mask != 0
* D. mask 每次左移 n 位
* E. result 通过 x 与掩码与的结果或来修改
* F. 如下

~~~C
long loop(long x, int n)
{
	long result = 0;
	long mask;
	for (mask = 1; mask != 0; mask <<= 1) {
		result |= (x & mask);
	}
	return result;
}
~~~

3.62

~~~C
typedef enum { MODE_A, MODE_B, MODE_C, MODE_D, MODE_E } mode_t;

long switch3(long *p1, long *p2, mode_t action)
{
	long result = 0;
	switch (action) {
		case MODE_A:
			result = *p2;
			*p2 = *p1;
			break;
		
		case MODE_B:
			result = *p1 + *p2;
			*p1 = result;
			break;
		
		case MODE_C:
			*p1 = 59;
			result = *p2;
			break;
			
		case MODE_D:
			*p1 = *p2;
			result = 27;
			break;
			
		case MODE_E:
			result = 27;
			break;
			
		default:
			result = 12;
			break;
	}
	return result;
}
~~~

3.63

~~~C
long switch_prob(long x, long n)
{
	long result = x;
	switch(n) {
		case 50:
		case 52:
			result = 8x;
			break;
		
		case 53:
			result = x;
			result >>= 3;
			break;
		
		case 54:
			x *= 15;
		case 55:
			x *= x;
		case 51:
			result = 75 + x;
			break;
	} 
	return result;
}
~~~

3.64

* A. 
* B.











