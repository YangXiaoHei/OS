2.85

* A. 数 7.0，即 111，即 1.11 * 2^2，因此 E = 2, `e = 2 + bias = 2 + 2^(k-1) - 1 = 2^(k-1) + 1`, f = 1.11, M = 0.11
* B. 假设指数为 k 位，小数 n 位，那么能够被准确描述的最大奇整数是 1 后面 n 个 1，即 `(1 << (n+1)) - 1`，即 `2^(n+1) - 1`
* C. 最小的规格化数为：指数最低位为 1，尾数全为 0，即 `0 0000...1 000000...`，偏置为 `2^(k-1) - 1`，则阶码为 : `E = 1 - 2^(k-1) + 1 = 2 - 2^(k-1)`，因此公式为 `1/(2 - 2^(k-1))`

2.86

* 偏置为 `2^14-1 = 16383`
* E 最大为 `2^14 = 16384`
* 最大规格化数的阶码为 `(1 << 15) - 1 - 1 = 2^15 - 2 - 2^14 + 1 = 2^14 - 1` = 16383
* 最大的规格化数为 : `2^16383 * 1.11111....` 即 `111...111 * 2^16320`，即 `((1 << 64) - 1) * 2^16320` 即 `(2^64 - 1) * 2^16320`

|描述|值|十进制|
|:--:|:--:|:--:|
|最小的正非规格化数|`0x00000000000000000001`| 2^-16383 * 2^-63 = 2^-16446 |
|最小的正规格化数|`0x00018000000000000000`|2^-16382|
|最大的规格化数|`0x7ffeffffffffffffffff`|`(2^64 - 1) * 2^16320`|

2.87

* 阶码位为 5 位，因此偏置为 2^4-1 = 15

* 2 的表示位 2^1 * 1.0, 即 E = 1, e = E + 15 = 16，即 10000, 而尾数全为 0，因此在此基础上 > 2 最小的值是 `0 10000 0000000001` 即 `0100 0000 0000 0001` 即 0x4001	

* 512 的 16 进制表示位为 0x200，即 001000000000，因此等于 2^9 * 1.0，阶码为 E = 9，指数为 9 + 15 = 24,  即 `16 + 8 = 11000`，尾数全为 0，因此二进制位为 `0 11000 0000000000`，因此十六进制为 `0x6000`

~~~C
16 | 512
16 | 32   0
     2    0
			2
~~~

* 最大的非规格化数为 `0 00000 1111111111`，因此 16 进制为 `0x03ff`, 尾数为 `(512 + 256 + 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1)/1024 = 1023/1024`，阶码为 -14

* 3bb0 = `0 01110 1110110000` 小数为 `(32 + 16 + 8 + 2 + 1)/64 = 59/64`，因此尾数为 `123/64` E = -1

|描述|Hex|M|E|V|D|
|:--:|:--:|:--:|:--:|:--:|:--:|
|-0|0x8000|0|-14|-0|-0.0|
|最小的 > 2 的值 |0x4001|`1025/1024`|1|`2^1 * 1025/1024`|`2.001953125`|
|512|0x6000|1.0|9|2^9 * 1.0|512.0|
|最大的非规格化数|0x03ff|`1023/1024`|-14|`2^-14 * 1023/1024`|`0.0000609756`|
|-∞|0xfc00|-|-|-|-|
|十六进制表示为 3BB0 的数|0x3bb0|`123/64`|-1|`2^-1 * 123/64`|`0.9609375`|

2.88

|格式 A||格式 B||
|:--:|:--:|:--:|:--:|
|位|值|位|值|
|`1 01110 001`|-9/16|`1 0110 0010`|-9/16|
|`0 10110 101`|208|`0 1110 1010`|208|
|`1 00111 110`| -7/1024 |`1 0000 0111`| -7/1024 |  
|`0 00000 101`| 5/13072 |`0 0000 0000`| 0 | 
|`1 11011 000`|-4096|`1 1111 0000`|-∞|
|`0 11000 100`|768|`0 1111 0000`|+∞|

* 第 3 行计算过程

~~~C
2^-8 * 1.110 = 2^-6 * 0.0111
1/256 * (1 + 1/2 + 1/4) = 1/256 * 7/4 = 7/1024
~~~

* 第 4 行计算过程

~~~C
=> 2^-14 * 0.101 = 1/16384 * 5/8 = 5/13072
=> 2^-6 * 0.00000000101 
可以看到，尾数根本放不下，全部舍掉
~~~

* 第 5 行计算过程

~~~C
=> 2^12 * 1.0 
=> 格式 B 的指数范围是 -6 ~ 7, 因此溢出
由于符号位是 1，所以溢出到负无穷 ∞
~~~

* 第 6 行计算过程

~~~C
=> 2^9 * 1.1 = 512 * 3/2 = 768
=> 格式 B 的指数范围是 -6 ~ 7，因此溢出
由于符号位是 0，所以溢出到正无穷 ∞
~~~

2.89

* A. `(float)x == (float)dx` ✅，可能会有人产生疑问，这里 x 转到 float 不是可能舍入吗？是的，的确会舍入，但是 double 转 float 同样产生了舍入，舍入后结果一样，那么等于就恒成立
* B. `dx - dy == (double)(x - y)` ❌ 比如，当 `y == TMIN, x = 1` 时, `x - y` 溢出，结果为 `-2147483647`，而 dx-dy 结果为 2147483649
* C. `(dx + dy) + dz == dx + (dy + dz)` ✅
* D. `(dx * dy) * dz == dx * (dy * dz)` ❌ double 无法精确表达的最小正整数是 1 后面跟 52 个 0，再跟一个 1，就是 `2^53 + 1`，而两个 int 相乘会产生的最大数的的量级是 `2^62`, 因此假如产生舍入的话，那么很有可能不等。。例子暂时举不出来
* E.  假如 dx 为 0，那么 dx/dx 为无穷大，假如 dz 为非 0，那么 dz/dz 为 1






























